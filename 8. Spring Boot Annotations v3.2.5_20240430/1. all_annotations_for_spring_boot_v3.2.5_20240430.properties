===============================================================
 All Annotations related to the Spring Boot v3.2.5 ( 2024.04.30 )
===============================================================


-----------------------------------------------
01. @SpringBootApplication 
-----------------------------------------------

	- Refs: https://chat.openai.com/share/5a7d4b9f-d94a-4219-bcde-030fb51cff67

	- @SpringBootConfiguration(= @Configuration) + @EnableAutoConfiguration + @ComponentScan

	- Indicates a configuration class that declares one or more `@Bean` methods and also triggers auto-configuration and component scanning.
	- This is a convenience annotation that is equivalent to declaring `@SpringBootConfiguration`, `@EnableAutoConfiguration` and `@ComponentScan`.


-----------------------------------------------
02. @SpringBootConfiguration 
-----------------------------------------------

	- Refs: https://chatgpt.com/share/146a62a6-59a3-4a6c-93a0-73c8fe59a5d6?oai-dm=1

	- Indicates that a class provides Spring Boot application `@Configuration`. 
	- Can be used as an alternative to the Spring's standard `@Configuration` annotation so that configuration can be found automatically (for example in tests). 
	- Application should only ever include one `@SpringBootConfiguration` and most idiomatic Spring Boot applications will inherit it from `@SpringBootApplication`.



-----------------------------------------------
03. @EnableAutoConfiguration 
-----------------------------------------------

	- Refs: https://chatgpt.com/share/39e9df2a-e559-46db-8f97-85ca23c59dc6?oai-dm=1

	- Enable auto-configuration of the Spring Application Context, attempting to guess and configure beans that you are likely to need.
	- Auto-configuration classes are usually applied based on your classpath and what beans you have defined.
	- For example, if you have `tomcat-embedded.jar` on your classpath, you are likely to want a `TomcatServletWebServerFactory` 
	   (unless you have defined your own `ServletWebServerFactory` bean). 
	- When using `@SpringBootApplication`, the auto-configurationof the context is automatically enabled and adding this annotation has therefore no additional effect. 
	- Auto-configuration tries to be as intelligent as possible and will back-away as you define more of your own configuration.
	- You can always manually `exclude()` any configuration that you never want to apply ( use `excludeName()` if you don't have access to them ).
	- You can also exclude them through the `spring.autoconfigure.exclude` property.
	- Auto-configuration is always applied after user-defined beans have been registered. 
	- The package of the class that is annotated with `@EnableAutoConfiguration`, usually through `@SpringBootApplication`, has specific significance and is often used as a 'default'.
	   For example, it will be used when scanning for `@Entity` classes.
	-  It is generally recommended that you place `@EnableAutoConfiguration` (if you're not using `@SpringBootApplication`) in a root package so that all sub-packages and classes can be searched. 
	- Auto-configuration classes are regular Spring `@Configuration` beans.
	- They are located using `ImportCandidates`. 
	- Generally auto-configuration beans are `@Conditional` beans (most often using `@ConditionalOnClass` and `@ConditionalOnMissingBean` annotations).

	- Since:	1.0.0

	- See Also:
		@ConditionalOnBean
		@ConditionalOnMissingBean
		@ConditionalOnClass
		@AutoConfigureAfter
		@SpringBootApplication


-----------------------------------------------
04. @ComponentScan
-----------------------------------------------

	- Refs: https://chatgpt.com/share/307ba02f-55f4-4691-8433-811e5a042fd7?oai-dm=1

	- Configures component scanning directives for use with `@Configuration` classes. 
	- Provides support comparable to Spring's `<context:component-scan>` XML namespace element. 
	- Either `basePackageClasses` or `basePackages` (or its alias value) may be specified to define specific packages to scan.
	- If specific packages are not defined, scanning will occur recursively beginning with the package of the class that declares this annotation. 
	- Note that the `<context:component-scan>` element has an annotation-config attribute; however, this annotation does not.
	- This is because in almost all cases when using `@ComponentScan`, default annotation configprocessing (e.g. processing `@Autowired` and friends) is assumed.
	- Furthermore,when using `AnnotationConfigApplicationContext`, annotation config processors are always registered,
	   meaning that any attempt to disable them at the `@ComponentScan` level would be ignored. 

	- See `@Configuration`'s Javadoc for usage examples. 

	- `@ComponentScan` can be used as a repeatable annotation. 
	- `@ComponentScan` may also be used as a meta-annotationto create custom composed annotations with attribute overrides. 
	- Locally declared `@ComponentScan` annotations always take precedenceover and effectively hide `@ComponentScan` meta-annotations,
	   which allows explicit local configuration to override configuration that is meta-present (including composed annotations meta-annotated with `@ComponentScan`).

	- Since:	3.1
	- See Also:
		@Configuration


-----------------------------------------------
05. @Configuration
-----------------------------------------------

	- Refs: https://chatgpt.com/share/0ab271d2-89e9-4792-aaa6-733607316ef1?oai-dm=1

	- Indicates that a class declares one or more `@Bean` methods and may be processed by the Spring container
	  to generate bean definitions and service requests for those beans at runtime, 

	- for example: 

		 @Configuration
		 public class AppConfig {

		     @Bean
		     public MyBean myBean() {
		         // instantiate, configure and return bean ...
		     }
		 }

	- Bootstrapping `@Configuration` classes : 

		(1) Via `AnnotationConfigApplicationContext`

				`@Configuration` classes are typically bootstrapped 
				using either `AnnotationConfigApplicationContext` or its web-capable variant, `AnnotationConfigWebApplicationContext`. 

				A simple example with the former follows: 

					 AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
					 ctx.register(AppConfig.class);
					 ctx.refresh();

					 MyBean myBean = ctx.getBean(MyBean.class);
					 // use myBean ...
		 
				See the `AnnotationConfigApplicationContext` javadocs for further details, 
				and see `AnnotationConfigWebApplicationContex`t for web configuration instructions in a `Servlet container`. 

		(2) Via Spring <beans> XML

				As an alternative to registering `@Configuration` classes directly against an `AnnotationConfigApplicationContext`, 
				`@Configuration` classes may be declared as normal <bean> definitions within Spring XML files: 

					<beans>
							<context:annotation-config/>
							<bean class="com.acme.AppConfig"/>
					</beans>

				In the example above, `<context:annotation-config/>` is required in order to enable `ConfigurationClassPostProcessor`
				and other annotation-related post processors that facilitate handling `@Configuration` classes. 

		(3) Via component scanning

				Since `@Configuration` is meta-annotated with `@Component`, `@Configuration` classes are candidates for component scanning
					— for example, using `@ComponentScan` or Spring XML's `<context:component-scan/>` element 
					— and therefore may also take advantage of `@Autowired` / `@Inject` like any regular `@Component`. 

				In particular, if a single constructor is present, autowiring semantics will be applied transparently for that constructor: 

					 @Configuration
					 public class AppConfig {

					     private final SomeBean someBean;

					     public AppConfig(SomeBean someBean) {
					         this.someBean = someBean;
					     }

					     // @Bean definition using "SomeBean"

					 }

				`@Configuration` classes may not only be bootstrapped using component scanning, 
				but may also themselves configure component scanning using the `@ComponentScan` annotation: 

					 @Configuration
					 @ComponentScan("com.acme.app.services")
					 public class AppConfig {

					     // various @Bean definitions ...

					 }

	- See the `@ComponentScan` javadocs for details. 

	- Working with externalized values :

		(1) Using the Environment API

				Externalized values may be looked up by injecting the Spring `org.springframework.core.env.Environment` into a `@Configuration` class 
				— for example, using the `@Autowired` annotation: 

					 @Configuration
					 public class AppConfig {

					     @Autowired Environment env;

					     @Bean
					     public MyBean myBean() {
					         MyBean myBean = new MyBean();
					         myBean.setName(env.getProperty("bean.name"));
					         return myBean;
					     }
					 }

				Properties resolved through the `Environment` reside in one or more "propertysource" objects, 
				and `@Configuration` classes may contribute property sources to the `Environmen`t object using the `@PropertySource` annotation: 

					 @Configuration
					 @PropertySource("classpath:/com/acme/app.properties")
					 public class AppConfig {

					     @Inject Environment env;

					     @Bean
					     public MyBean myBean() {
					         return new MyBean(env.getProperty("bean.name"));
					     }
					 }

				See the Environmentand `@PropertySource` javadocs for further details. 

		(2) Using the `@Value` annotation

				Externalized values may be injected into `@Configuration` classes using the `@Value` annotation : 

					 @Configuration
					 @PropertySource("classpath:/com/acme/app.properties")
					 public class AppConfig {

					     @Value("${bean.name}") String beanName;

					     @Bean
					     public MyBean myBean() {
					         return new MyBean(beanName);
					     }
					 }

				This approach is often used in conjunction with Spring's `PropertySourcesPlaceholderConfigurer` 
				that can be enabled automatically in XML configuration via `<context:property-placeholder/>` or explicitly in a `@Configuration` class via a dedicated static `@Bean` method
				(see "a note on `BeanFactoryPostProcessor`-returning `@Bean` methods" of `@Bean`'s javadocs for details). 

				Note, however, that explicit registrationof a `PropertySourcesPlaceholderConfigurer` via a static `@Bean` method is typically only required
				if you need to customize configuration such as the placeholder syntax, etc. Specifically, 
				if no bean post-processor (such as a `PropertySourcesPlaceholderConfigurer`) has registered an embedded value resolver for the ApplicationContext, 
				Spring will register a default embedded value resolver which resolves placeholders against property sources registered in the `Environment`. 

				See the section below on composing `@Configuration` classes with Spring XML using `@ImportResource`; 
				see the `@Value` javadocs; and see the `@Bean` javadocs for details on working with `BeanFactoryPostProcessor` types such as `PropertySourcesPlaceholderConfigurer`. 

	- Composing `@Configuration` classes

		(1) With the `@Import` annotation

				`@Configuration` classes may be composed using the `@Import` annotation, similar to the way that `<import>` works in Spring XML. 
				Because `@Configuration` objects are managed as Spring beans within the container,imported configurations may be injected 

				— for example, via constructor injection : 

					 @Configuration
					 public class DatabaseConfig {

					     @Bean
					     public DataSource dataSource() {
					         // instantiate, configure and return DataSource
					     }
					 }

					 @Configuration
					 @Import(DatabaseConfig.class)
					 public class AppConfig {

					     private final DatabaseConfig dataConfig;

					     public AppConfig(DatabaseConfig dataConfig) {
					         this.dataConfig = dataConfig;
					     }

					     @Bean
					     public MyBean myBean() {
					         // reference the dataSource() bean method
					         return new MyBean(dataConfig.dataSource());
					     }
					 }

				Now both `AppConfig` and the imported `DatabaseConfig` can be bootstrapped by registering only `AppConfig` against the Spring context : 
 
 					new AnnotationConfigApplicationContext(AppConfig.class);

		(2) With the `@Profile` annotation

				 @Configuration classes may be marked with the `@Profile` annotation to indicate they should be processed only if a given profile or profiles are active : 

					 @Profile("development")
					 @Configuration
					 public class EmbeddedDatabaseConfig {

					     @Bean
					     public DataSource dataSource() {
					         // instantiate, configure and return embedded DataSource
					     }
					 }

					 @Profile("production")
					 @Configuration
					 public class ProductionDatabaseConfig {

					     @Bean
					     public DataSource dataSource() {
					         // instantiate, configure and return production DataSource
					     }
					 }

				Alternatively, you may also declare profile conditions at the `@Bean` method level 
					— for example, for alternative bean variants within the same configuration class :

					 @Configuration
					 public class ProfileDatabaseConfig {

					     @Bean("dataSource")
					     @Profile("development")
					     public DataSource embeddedDatabase() { ... }

					     @Bean("dataSource")
					     @Profile("production")
					     public DataSource productionDatabase() { ... }

					 }

				See the `@Profile` and `org.springframework.core.env.Environmen` tjavadocs for further details. 

		(3) With Spring XML using the `@ImportResource` annotation

				As mentioned above, `@Configuration` classes may be declared as regular Spring `<bean>` definitions within Spring XML files.
				It is also possible to import Spring XML configuration files into `@Configuration` classes using the `@ImportResource` annotation.

				Bean definitions imported from XML can be injected — for example, using the `@Inject` annotation : 

					 @Configuration
					 @ImportResource("classpath:/com/acme/database-config.xml")
					 public class AppConfig {

					     @Inject DataSource dataSource; // from XML

					     @Bean
					     public MyBean myBean() {
					         // inject the XML-defined dataSource bean
					         return new MyBean(this.dataSource);
					     }
					 }

		(4) With nested `@Configuration` classes

				`@Configuration` classes may be nested within one another as follows : 

					 @Configuration
					 public class AppConfig {

					     @Inject DataSource dataSource;

					     @Bean
					     public MyBean myBean() {
					         return new MyBean(dataSource);
					     }

					     @Configuration
					     static class DatabaseConfig {

					         @Bean
					         DataSource dataSource() {
					             return new EmbeddedDatabaseBuilder().build();
					         }

					     }

					 }

				When bootstrapping such an arrangement, only `AppConfig` need be registered against the application context. 
				By virtue of being a nested `@Configuration` class, `DatabaseConfig` will be registered automatically.
				This avoids the need to use an `@Import` annotation when the relationship between `AppConfig` and `DatabaseConfig` is already implicitly clear. 

	- Note also that nested `@Configuration` classes can be used to good effect with the `@Profile` annotation 
	  to provide two options of the same bean to the enclosing `@Configuration` class. 

	- Configuring lazy initialization

		By default, `@Bean` methods will be eagerly instantiated at container bootstrap time. 
		To avoid this, `@Configuration` may be used in conjunction with the `@Lazy` annotation to indicate that all `@Bean` methods declared within the class are by default lazily initialized.
		Note that `@Lazy` may be used on individual `@Bean` methods as well. 

	- Testing support for `@Configuration` classes

		The `Spring TestContext framework` available in the spring-test module provides the `@ContextConfiguration` annotation 
		which can accept an array of component class references — typically `@Configuration` or `@Component` classes. 
 		
 			 @ExtendWith( SpringExtension.class )
			 @ContextConfiguration(classes = { AppConfig.class, DatabaseConfig.class })
			 class MyTests {

			     @Autowired MyBean myBean;
			     @Autowired DataSource dataSource;

			     @Test
			     void test() {
			         // assertions against myBean ...
			     }
			 }

		See the `TestContext framework` reference documentation for details. 

	- Enabling built-in Spring features using `@Enable` annotations

		Spring features such as `asynchronous` method execution, scheduled task execution, annotation driven transaction management, 
		and even Spring MVC can be enabled and configured from `@Configuration` classes using their respective "@Enable"annotations. 

		See `@EnableAsync`, `@EnableScheduling`, `@EnableTransactionManagement`, `@EnableAspectJAutoProxy`, and `@EnableWebMvc` for details. 

	- Constraints when authoring `@Configuration` classes
		• `Configuration` classes must be provided as classes (i.e. not as instances returned from factory methods), allowing for runtime enhancements through a generated subclass. 
		• `Configuration` classes must be `non-final` (allowing for subclasses at runtime), 
			unless the `proxyBeanMethods` flag is set to `false` in which case no runtime-generated subclass is necessary. 
		• `Configuration` classes must be `non-local` (i.e. may not be declared within a method). 
		• Any nested configuration classes must be declared as `static`.
		• `@Bean` methods may not in turn create further configuration classes 
			(any such instances will be treated as regular beans, with their configuration annotations remaining undetected). 

	- Since:	3.0

	- See Also:
		@Bean
		@Profile
		@Import
		@ImportResource
		@ComponentScan
		@Lazy
		@PropertySource

		`AnnotationConfigApplicationContext`
		`ConfigurationClassPostProcessor`
		`org.springframework.core.env.Environment`
		`org.springframework.test.context.ContextConfiguration`


-----------------------------------------------
06. @ServletComponentScan
-----------------------------------------------

	- Refs: https://chat.openai.com/share/ebd7c167-db46-4ca4-97d5-ee27f68457e6

	- Enables scanning for Servlet components ( filters, servlets, and listeners ).
	- Scanning is *Only performed when using an `embedded` web server. 
	- Typically, one of value, `basePackages`, or `basePackageClasses` should be specified to control the packages to be scanned for components.
	- In their absence, scanning will be performed from the package of the class with the annotation.

	-	Since:	1.3.0
	-	See Also:
			@WebServlet
			@WebFilter
			@WebListener


-----------------------------------------------
07. @Bean
-----------------------------------------------

	- Refs: https://chatgpt.com/share/594e88f9-79c2-42de-b028-daf3a6ecbce0
	
	- Example:	@Bean(initMethod = "initBean", destroyMethod = "destroyBean")

	- The *order of invocation when a Bean is created : 

		(1) @PostConstruct	
		(2) IntializingBean.afterPropertiesSet()
		(3) @Bean(initMethod)

	- The *order of invocation when a Bean is destroyed : 

		(1) @PreDestroy
		(2) DisposableBean.destroy()
		(3) @Bean(destroyMethod)

	- Indicates that a method produces a bean to be managed by the Spring container. 

		(1) Overview

				The names and semantics of the attributes to this annotation are intentionally similar to those of the `<bean/>` element in the Spring XML schema. 

				For example: 

				     @Bean
				     public MyBean myBean() {
				         // instantiate and configure MyBean obj
				         return obj;
				     }
				 
		(2) Bean Names

				While a name attribute is available, the default strategy for determining the name of a bean is to use the name of the `@Bean` method.
				This is convenient and intuitive, but if explicit naming is desired, the name attribute (or its alias value) may be used. 
				Also note that name accepts an array of Strings, allowing for multiple names (i.e. a primary bean name plus one or more aliases)  for a single bean. 

				     @Bean({"b1", "b2"}) // bean available as 'b1' and 'b2', but not 'myBean'
				     public MyBean myBean() {
				         // instantiate and configure MyBean obj
				         return obj;
				     }
 
		(3) Profile, Scope, Lazy, DependsOn, Primary, Order

				Note that the `@Bean` annotation does not provide attributes for profile, scope,  lazy,  depends-on or primary. 
				Rather, it should be used in conjunction with `@Scope`, `@Lazy`, `@DependsOn` and `@Primary` annotations to declare those semantics. 

				For example: 

				     @Bean
				     @Profile("production")
				     @Scope("prototype")
				     public MyBean myBean() {
				         // instantiate and configure MyBean obj
				         return obj;
				     }
 
				The semantics of the above-mentioned annotations match their use at the component class level: 
					`@Profile` allows for selective inclusion of certain beans. 
					`@Scope` changes the bean's scope from singleton to the specified scope. 
					`@Lazy` only has an actual effect in case of the default singleton scope. 
					`@DependsOn` enforces the creation of specific other beans before this bean will be created, 
										   in addition to any dependencies that the bean expressed through direct references, which is typically helpful for singleton startup. 
					`@Primary` is a mechanism to resolve ambiguity at the injection point level if a single target component needs to be injected but several beans match by type. 

				Additionally, `@Bean` methods may also declare qualifier annotations and `@Order` values, to be taken into account 
				during injection point resolution just like corresponding annotations on the corresponding component classes 
				but potentially being very individual per bean definition ( in case of multiple definitions with the same bean class ). 

				Qualifiers narrow the set of candidates after the initial type match; order values determine the order of resolved elements in case of collection injection points 
				(with several target beans matching by type and qualifier). 

				NOTE: `@Order` values may influence priorities at injection points, but please be aware that they do not influence singleton startup order
							which is anorthogonal concern determined by dependency relationships and `@DependsOn` declarations as mentioned above. 

							Also, `jakarta.annotation.Priority` is notavailable at this level since it cannot be declared on methods; 
							its semantics can be modeled through `@Order` values in combination with `@Primary` on a single bean per type. 

		(4) @Bean Methods in @Configuration Classes

				Typically, `@Bean` methods are declared within `@Configuration` classes. 
				In this case, bean methods may reference other `@Bean` methods in the same class by calling them directly.
				This ensures that references between beans are strongly typed and navigable. 

				Such so-called 'inter-bean references' are guaranteed to respect scoping and AOP semantics, just like `getBean()` lookups would. 
				These are the semantics known from the original 'Spring JavaConfig' project which require `CGLIB` subclassing of each such configuration class at runtime. 

				As a consequence, `@Configuration` classes and their factory methods must not be marked as final or private in this mode. 

				For example: 

					 @Configuration
					 public class AppConfig {

					     @Bean
					     public FooService fooService() {
					         return new FooService(fooRepository());
					     }

					     @Bean
					     public FooRepository fooRepository() {
					         return new JdbcFooRepository(dataSource());
					     }

					     // ...
					 }

		(5) @Bean Lite Mode

				`@Bean` methods may also be declared within classes that are not annotated with `@Configuration`. 
				If a bean method is declared on a bean that is not annotated with `@Configuration` it is processed in aso-called 'lite' mode. 

				Bean methods in lite mode will be treated as plain factory methods by the container (similar to factory-method declarationsin XML), 
				with scoping and lifecycle callbacks properly applied. 

				The containing class remains unmodified in this case, and there are no unusual constraints for the containing class or the factory methods. 
				In contrast to the semantics for bean methods in `@Configuration` classes, 'inter-bean references' are not supported in lite mode. 

				Instead,when one `@Bean`-method invokes another `@Bean`-method in lite mode, the invocation is a standard Java method invocation; 
				Spring does not intercept the invocation via a `CGLIB proxy`. 

				This is analogous to inter-`@Transactional` method calls where in proxy mode, Spring does not intercept the invocation 
					— Spring does so only in `AspectJ` mode. 

				For example: 

					 @Component
					 public class Calculator {
					     public int sum(int a, int b) {
					         return a+b;
					     }

					     @Bean
					     public MyBean myBean() {
					         return new MyBean();
					     }
					 }

		(6) Bootstrapping

				See the `@Configuration` javadoc for further details including how to bootstrap the container using `AnnotationConfigApplicationContext` and friends. 

				`BeanFactoryPostProcessor`-returning `@Bean` methods

				Special consideration must be taken for `@Bean` methods that return `Spring BeanFactoryPostProcessor (BFPP)` types. 
				Because `BFPP` objects must be instantiated very early in the container lifecycle,
				they can interfere with processing of annotations such as `@Autowired`, `@Value`, and `@PostConstruct` within `@Configuration` classes.
				To avoid these lifecycle issues, mark `BFPP`-returning `@Bean` methods as `static`. 

 				For example: 

				     @Bean
				     public static PropertySourcesPlaceholderConfigurer pspc() {
				         // instantiate, configure and return pspc ...
				     }
 
				By marking this method as `static`, it can be invoked without causing instantiation of its declaring `@Configuration` class, 
				thus avoiding the above-mentioned lifecycle conflicts.

				Note however that `static @Bean` methods will not be enhanced for scoping and AOP semantics as mentioned above. 
				This works out in `BFPP` cases, as they are not typically referenced by other `@Bean` methods. 

				As a reminder, an INFO-level log message will beissued for any non-static `@Bean` methods having a return type assignable to `BeanFactoryPostProcessor`.

	- Since:• 3.0

	- See Also:
			@Configuration
			@Scope
			@DependsOn
			@Lazy
			@Primary

			`org.springframework.stereotype.Component`
			`org.springframework.beans.factory.annotation.Autowired`
			`org.springframework.beans.factory.annotation.Value`


-----------------------------------------------
08. @Component
-----------------------------------------------

	- Refs: https://chatgpt.com/share/871cce4f-07ed-416e-a1ea-74569adfd1ae?oai-dm=1

	- Indicates that the annotated class is a component. 
	- Such classes are considered as candidates for auto-detection when using annotation-based configuration and classpath scanning. 
	- A component may optionally specify a logical component name via the value attribute of this annotation. 
	- Other class-level annotations may be considered as identifying a component as well, typically a special kind of component 
		— for example, the `@Repository` annotation or AspectJ's `@Aspect` annotation.
	- Note, however, that the `@Aspect` annotation does not automatically make a class eligible for classpath scanning. 
	- Any annotation meta-annotated with `@Component` is considered a stereotype annotation which makes the annotated class eligible for classpath scanning.
		For example, `@Service`, `@Controller`, and `@Repository` are stereotype annotations. 
	- Stereotype annotations may also support configuration of a logical component name by overriding the value attribute of this annotation via `@AliasFor`. 
	- As of Spring Framework 6.1, support for configuring the name of a stereotype component by convention (i.e., via a String `value()` attribute without `@AliasFor`) is deprecated 
	  and will be removed in a future version of the framework. 
	- Consequently, custom stereotype annotations must use `@AliasFo` rto declare an explicit alias for this annotation's value attribute.
	- See the source code declaration of `Repository.value()` and `ControllerAdvice.name()` for concrete examples.

	- Since:	2.5

	- See Also:
			@Repository
			@Service
			@Controller

			`org.springframework.context.annotation.ClassPathBeanDefinitionScanner`


-----------------------------------------------
00. @PostConstruct
-----------------------------------------------

	- Refs: https://chatgpt.com/share/63c0b21c-6ff2-43c7-bc99-a8d36f452f49?oai-dm=1

	- The *order of invocation when a Bean is created : 

			(1) @PostConstruct	
			(2) IntializingBean.afterPropertiesSet()
			(3) @Bean(initMethod)

	- import jakarta.annotation.PostConstruct;

	- The `@PostConstruct` annotation is used on a method that needs to be executed after dependency injection is done to performany initialization.
	- This method must be invoked before the class is put into service.
	- This annotation must be supported on all classes that support dependency injection.
	- The method annotated with `@PostConstruct` must be invoked even if the class does not request any resources to be injected.
	- Only one method in a given class can be annotated with this annotation.

	- The method on which the `@PostConstruct` annotation is applied must fulfill all of the following criteria: 
		• The method must not have any parameters except in the case of interceptors in which case it takes an `InvocationContext` object as defined by the `Jakarta Interceptors specification`.

		• The method defined on an interceptor class or superclass of an interceptor class must have one of the following signatures : 

			void <METHOD>(InvocationContext) 
			Object <METHOD>(InvocationContext) throws Exception 

			Note: A `PostConstruct` interceptor method must not throw application exceptions, but it may be declared to throw `checked` exceptions including the `java.lang.Exception`
	   				  if the same interceptor method interposes on business or timeout methods in addition to lifecycle events.
	   				  If a `PostConstruct` interceptor method returns a value, it is ignored by the container. 

		• The method defined on a `non-interceptor` class must have thefollowing signature: 

			void <METHOD>() 

		• The method on which the `@PostConstruct` annotation is applied may be public, protected, package private or private.
		• The method must not be static except for the application client.
		• The method should not be final.
		• If the method throws an `unchecked` exception, the class must not be put into service except in the case where the exception is handled by an interceptor.

	- Since:	1.6, Common Annotations 1.0

	- See Also:
			jakarta.annotation.PreDestroy
			jakarta.annotation.Resource


-----------------------------------------------
00. @PreDestroy
-----------------------------------------------

	- Refs: https://chat.openai.com/share/9e3a21b5-a6bb-48cf-8960-27c174824aba

	- The *order of invocation when a Bean is destroyed : 

			(1) @PreDestroy
			(2) DisposableBean.destroy()
			(3) @Bean(destroyMethod)

	- The `@PreDestroy` annotation is used on a method as a callback notification to signal that the instance is in the process of being removed by the container.
	- The method annotated with `@PreDestroy` is typically used to release resources that it has been holding.
	- This annotation must be supported by all container-managed objects that support the use ofthe `@PostConstruct` annotation except the Jakarta EE applicationclient.

	- The method on which the `@PreDestroy` annotation is applied must fulfill all of the following criteria: 
		• The method must not have any parameters except in the case of interceptors in which case it takes an `InvocationContext` object as defined by the Jakarta Interceptors specification.

		• The method defined on an interceptor class or superclass of an interceptor class must have one of the following signatures: 

			void <METHOD>(InvocationContext) 
			Object <METHOD>(InvocationContext) throws Exception 

			Note: A `PreDestroy` interceptor method must not throw `application` exceptions, 
					 but it may be declared to throw `checked` exceptions including the `java.lang.Exception` 
					 if the same interceptor method interposes on business or timeout methods in addition to lifecycle events. 
					 If a `PreDestroy` interceptor method returns a value, it is ignored by the container. 

		• The method defined on a non-interceptor class must have thefollowing signature :

			void <METHOD>() 

		• The method on which `@PreDestroy` is applied may be `public`, `protected`, `package private` or `private`.
		• The method must not be `static`.
		• The method should not be `final`.
		• If the method throws an `unchecked` exception it is ignored by the container.

	- Since:	1.6, Common Annotations 1.0

	- See Also:
			jakarta.annotation.PostConstruct
			jakarta.annotation.Resource


-----------------------------------------------
00. @DependsOn
-----------------------------------------------

	- Refs: https://chatgpt.com/share/1f020d80-76ee-40b8-af13-a5d464033fee?oai-dm=1

	- Beans on which the current bean depends.
	- Any beans specified are guaranteed to be created by the container before this bean.
	- Used in frequently in cases where a bean does not explicitly depend on another through properties or constructor arguments, 
	   but rather depends on the side effects of another bean's initialization. 
	- A depends-on declaration can specify both an initialization-time dependency and, in the case of singleton beans only, a corresponding destruction-time dependency.
	- Dependent beans that define a `depends-on relationship` with a given bean are destroyed first, prior to the given bean itself being destroyed.
	- Thus, a `depends-on` declaration can also control `shutdown order`. 
	- May be used on any class directly or indirectly annotated with `org.springframework.stereotype.Component` or on methods annotated with `Bean`. 
	- Using `@DependsOn` at the class level has no effect unless component-scanning is being used.
	- If a `@DependsOn`-annotated class is declared via XML, `@DependsOn` annotation metadata is ignored, and `<bean depends-on="..."/>` is respected instead.

	- Since:	3.0


-----------------------------------------------
00. @Priority
-----------------------------------------------

	- Refs: https://chatgpt.com/share/5ad372ee-82c0-4789-aa72-122a9ecb7d01?oai-dm=1

	- import `jakarta.annotation.Priority`;

	- The `@Priority` annotation can be applied to any program elements to indicate in what order they should be used.
	- The effect of using the `@Priority` annotation in any particular instance is defined by other specifications that define the use of a specific class. 
	- For example, the `Jakarta Interceptors specification` defines the use of `priorities` on interceptors to control the order in which interceptors are called.
	- Priority values should generally be `non-negative`, with negative values reserved for special meanings such as "undefined" or "not specified".
	- A specification that defines use of the `@Priority` annotation may define the range of allowed priorities and any priority values with special meaning.

	- Since:	Common Annotations 1.2


-----------------------------------------------
00. @Order
-----------------------------------------------

	- Refs: https://chatgpt.com/share/01318230-e067-4892-9a65-f735f38a9034?oai-dm=1

	- `@Order` defines the sort order for an annotated component. 
	- The value is optional and represents an order value as defined in the `Ordered` interface.
	- Lower values have higher priority.
	- The default value is `Ordered.LOWEST_PRECEDENCE`, indicating the lowest priority (losing to anyother specified order value). 
	- NOTE: Since Spring 4.0, annotation-based ordering is supported for many kinds of components in Spring, 
				 even for collection injection where the order values of the target components are taken into account
				 (either from their target class or from their `@Bean` method). 

				 While such order values may influence priorities at injection points, please be aware that they do not influence singleton startup order
				 which is an orthogonal concern determined by dependency relationships and `@DependsOn` declarations (influencing a runtime-determined dependency graph). 

	- Since Spring 4.1, the standard `jakarta.annotation.Priority` annotation can be used as a drop-in replacement for this annotation in ordering scenarios.
	- Note that `@Priority` may have additional semantics when a single element has to be picked (see `AnnotationAwareOrderComparator.getPriority`). 
	- Alternatively, order values may also be determined on a per-instance basis through the `Ordered` interface, 
	  allowing for configuration-determined instance values instead of hard-coded values attached to a particular class. 
	- Consult the javadoc for `OrderComparator` for details on the sort semantics for non-ordered objects.

	- Since:	2.0

	- See Also:
			org.springframework.core.Ordered
			AnnotationAwareOrderComparator
			OrderUtils
			jakarta.annotation.Priority


-----------------------------------------------
00. @Deprecated
-----------------------------------------------

	- Refs: https://chatgpt.com/share/aa9a2a86-4178-47b1-b1c1-ce93bb44af42?oai-dm=1

	- A program element annotated `@Deprecated` is one that programmers are discouraged from using.
	- An element may be deprecated for any of several reasons, for example, its usage is likely to lead to errors; 
	   it maybe changed incompatibly or removed in a future version; it has beensuperseded by a newer, usually preferable alternative; or it is obsolete. 
	- Compilers issue warnings when a deprecated program element is used oroverridden in non-deprecated code.
	- Use of the `@Deprecated` annotation on a local variable declaration or on a parameter declaration or a package declaration has no effect on the warnings issued by a compiler. 
	- When a module is deprecated, the use of that module in requires, but not in exports or opens clauses causes a warning to be issued.
	- A module being deprecated does not cause warnings to be issued for uses of types within the module. 
	- This annotation type has a string-valued element since.
	- The valueof this element indicates the version in which the annotated program elementwas first deprecated. 
	- This annotation type has a boolean-valued element forRemoval.
	- A value of true indicates intent to remove the annotated programelement in a future version.
	- A value of false indicates that use ofthe annotated program element is discouraged, but at the time the programelement was annotated, there was no specific intent to remove it.

	- Since:	1.5

	- API Note:	It is strongly recommended that the reason for deprecating a program elementbe explained in the documentation, using the `@deprecated` javadoc tag.
	  					The documentation should also suggest and link to arecommended replacement API, if applicable.
	  					A replacement API oftenhas subtly different semantics, so such issues should be discussed as well. 

	- It is recommended that a since value be provided with all newlyannotated program elements. 
	- Note that since cannot be mandatory,as there are many existing annotations that lack this element value. 
	- There is no defined order among annotation elements. As a matter ofstyle, the since element should be placed first. 
	- The `@Deprecated` annotation should always be present if the `@deprecated` javadoc tag is present, and vice-versa.

	- @jls• 9.6.4.6 @Deprecated


-----------------------------------------------
00. @WebServlet
-----------------------------------------------

	- Refs: https://chat.openai.com/share/27ed9ce8-b6bf-4636-a73a-4826a226fc6c

	- 


-----------------------------------------------
00. @WebFilter
-----------------------------------------------

	- Refs: https://chat.openai.com/share/fad7e8e1-0bae-49c0-a706-f41363fe45db

	- 


-----------------------------------------------
00. @WebListener
-----------------------------------------------

	- Refs: https://chat.openai.com/share/09776ad5-dfec-4de6-b821-1aa666cbca26

	- 


-----------------------------------------------
00. @Controller
-----------------------------------------------

	- Refs: https://chat.openai.com/share/8928e6b5-e1cd-444a-a1d3-85848995db30

	- 


-----------------------------------------------
00. @RestController
-----------------------------------------------

	- Refs: https://chatgpt.com/share/871cce4f-07ed-416e-a1ea-74569adfd1ae?oai-dm=1

	- 


-----------------------------------------------
00. @Service
-----------------------------------------------

	- Refs: https://chatgpt.com/share/d59f6085-96e9-4d99-8cf2-e3052a8d4521?oai-dm=1

	- 


-----------------------------------------------
00. @Repository
-----------------------------------------------

	- Refs: https://chatgpt.com/share/7711b76d-6d6d-45d4-83fb-04b6d1b57ce0?oai-dm=1

	- 


-----------------------------------------------
00. @ConfigurationProperties
-----------------------------------------------

	- Refs: https://chatgpt.com/share/0d79f49d-901c-4ae3-bffc-8389514e875d?oai-dm=1

	- Annotation for externalized configuration.
	- Add this to a class definition or a `@Bean` method in a `@Configuration` class if you want to bind and validate some external Properties (e.g. from a .properties file). 
	- `Binding` is either performed by calling `setters` on the annotated class or, if `@ConstructorBinding` is in use, by binding to the constructor parameters. 
	- Note that contrary to `@Value`, SpEL expressions are not evaluated since property values are externalized.

	- Since:	1.0.0

	- See Also:
			@ConfigurationPropertiesScan
			@ConstructorBinding
			@ConfigurationPropertiesBindingPostProcessor
			@EnableConfigurationProperties


-----------------------------------------------
00. @EnableConfigurationProperties
-----------------------------------------------

	- Refs: https://chatgpt.com/share/e13f4a3f-5f61-4f0d-a785-cf241422ce0c?oai-dm=1

	- Enable support for `@ConfigurationProperties` annotated beans.
	- `@ConfigurationProperties` beans can be registered in the standard way (for example using `@Bean` methods) or, 
		for convenience, can be specified directly on this annotation.

	- Since:	1.0.0


-----------------------------------------------
00. @ConstructorBinding
-----------------------------------------------

	- Refs: https://chatgpt.com/share/0882f75c-027a-42d1-9161-cda96032108c?oai-dm=1

	- Annotation that can be used to indicate which constructor to use when binding configuration properties using `constructor arguments` rather than by calling `setters`.
	- A single parameterized constructor implicitly indicates that constructor binding should be used unless the constructor is annotated with `@Autowired`.

	- Since:	3.0.0


-----------------------------------------------
00. @ConfigurationPropertiesScan
-----------------------------------------------

	- Refs: https://chatgpt.com/share/bdf88287-97ff-4782-ab6b-618b7b24396d?oai-dm=1

	- Configures the base packages used when scanning for `@ConfigurationProperties` classes.
	- One of `basePackageClasses()`, `basePackages()` or its alias `value()` may be specified to define specific packages to scan.
	- If specific packages are not defined scanning will occur from the package of the class with this annotation. 
	- Note: Classes annotated or meta-annotated with `@Component` will not be picked up by this annotation.

	- Since:	2.2.0


-----------------------------------------------
00. @ConfigurationPropertiesBindingPostProcessor
-----------------------------------------------

	- Refs: https://chatgpt.com/share/7d9be05b-7fe6-4ff7-834c-0ce93df17ee7?oai-dm=1

	- 


-----------------------------------------------
00. @ConfigurationPropertiesBinding 
-----------------------------------------------

	- Refs: https://chatgpt.com/share/40cf0147-87aa-4c19-a7aa-ab75dedf6562?oai-dm=1

	- 


-----------------------------------------------
00. @EnableJpaAuditing
-----------------------------------------------

	- Refs: https://chatgpt.com/share/e0bdf0ff-1aaa-47f9-8631-a1f3375a77af?oai-dm=1

	- Annotation to enable auditing in JPA via annotation configuration

	- See Also:
			@CreatedDate
			@LastModifiedDate


-----------------------------------------------
00. @CreatedDate
-----------------------------------------------

	- Refs: https://chatgpt.com/share/a3129fc3-0b6b-4972-a5c5-87e8f7c76629?oai-dm=1

	- Declares a field as the one representing the date the entity containing the field was created.

	- See Also:
			@EnableJpaAuditing


-----------------------------------------------
00. @LastModifiedDate
-----------------------------------------------

	- Refs: https://chat.openai.com/share/568215ef-40d3-415e-85cb-79fb96b49abc

	- Declares a field as the one representing the date the entity containing the field was recently modified.

	- See Also:
			@EnableJpaAuditing


-----------------------------------------------
00. @EntityScan
-----------------------------------------------

	- Refs: https://chat.openai.com/share/931a6ffa-6b4a-40d6-bc45-31fbfff6c0c3

	- Configures the base packages used by auto-configuration when scanning for entityclasses. 
	- Using `@EntityScan` will cause auto-configuration to: 
		•Set the packages scanned for JPA entities.
		•Set the initial entity set used with Spring Data MongoDB, Neo4j, Cassandra and Couchbase mapping contexts.
	- One of `basePackageClasses()`, `basePackages()` or its alias `value()` may be specified to define specific packages to scan.
	- If specific packages are not defined, scanning will occur from the package of the class with this annotation.

	- Since:	1.4.0


-----------------------------------------------
00. @Autowired
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. @Transactional
-----------------------------------------------

	- Refs: https://chatgpt.com/share/b2304f01-b216-40fa-83b9-50c5f538228c?oai-dm=1

	- Describes a transaction attribute on an individual method or on a class. 
	- When this annotation is declared at the class level, it applies as a default to all methods of the declaring class and its subclasses.
	- Note that it does not apply to ancestor classes up the class hierarchy; inherited methods need to be locally redeclared in order to participate in a subclass-level annotation.
	- For details on method visibility constraints, consult the Transaction Managementsection of the reference manual. 
	- This annotation is generally directly comparable to Spring's `org.springframework.transaction.interceptor.RuleBasedTransactionAttribute` class, 
	   and in fact Annotation Transaction Attribute Source will directly convert this annotation's attributes to properties in `RuleBasedTransaction` Attribute, 
	   so that Spring's transaction support code does not have to know about annotations.

	- Attribute Semantics
		If no custom rollback rules are configured in this annotation, the transaction will roll back on `RuntimeException` and `Error` but not on `checked` exceptions. 
		Rollback rules determine if a transaction should be rolled back when a given exception is thrown, and the rules are based on types or patterns.
		Custom rules may be configured via `rollbackFor` / `noRollbackFor` and `rollbackForClassName` / `noRollbackForClassName`, 
		which allowrules to be specified as types or patterns, respectively. 
		When a rollback rule is defined with an exception type, that type will be used to match against the type of a thrown exception and its super types, 
		providing type safety and avoiding any unintentional matches that may occurwhen using a pattern. 
		For example, a value of `jakarta.servlet.ServletException.class` will only match thrown exceptions of type `jakarta.servlet.ServletException` and its subclasses. 
		When a rollback rule is defined with an exception pattern, the pattern canbe a fully qualified class name or a substring of a fully qualified class name 
		for an exception type (which must be a subclass of Throwable), with no wildcard support at present. 
		For example, a value of "jakarta.servlet.ServletException" or "ServletException" will match `jakarta.servlet.ServletException` and its subclasses. 
		- WARNING: You must carefully consider how specific a patternis and whether to include package information (which isn't mandatory). 
		For example, "Exception" will match nearly anything and will probably hide otherrules. 
		"java.lang.Exception" would be correct if "Exception"were meant to define a rule for all checked exceptions. 
		With more unique exception names such as "BaseBusinessException" there is likely noneed to use the fully qualified class name for the exception pattern. 
		Furthermore, rollback rules defined via patterns may result in unintentional matches for similarly named exceptions and nested classes. 
		This is due to the fact that athrown exception is considered to be a match for a given pattern-based rollback rule
		if the name of thrown exception contains the exception pattern configured for the rollback rule. 
		For example, given a rule configured to match against "com.example.CustomException", 
		that rule will match against an exception named com.example.CustomExceptionV2 (an exception in the same package as CustomException but with an additional suffix) or 
		an exception named com.example.CustomException$AnotherException (an exception declared asa nested class in CustomException). 
		For specific information about the semantics of other attributes in thisannotation, 
		consult the org.springframework.transaction.TransactionDefinitionand org.springframework.transaction.interceptor.TransactionAttribute javadocs. 

	- Transaction Management

		This annotation commonly works with thread-bound transactions managed by a org.springframework.transaction.PlatformTransactionManager, 
		exposing atransaction to all data access operations within the current execution thread. Note: This does NOT propagate to newly started threads within the method. 
		Alternatively, this annotation may demarcate a reactive transaction managedby a org.springframework.transaction.ReactiveTransactionManager 
		which uses the Reactor context instead of thread-local variables. 

		As a consequence,all participating data access operations need to execute within the sameReactor context in the same reactive pipeline. 

		Note: When configured with a ReactiveTransactionManager, alltransaction-demarcated methods are expected to return a reactive pipeline.
				  Void methods or regular return types need to be associated with a regular PlatformTransactionManager, e.g. through transactionManager().

	- Since:• 1.2

	See Also:
		org.springframework.transaction.interceptor.TransactionAttribute
		org.springframework.transaction.interceptor.DefaultTransactionAttribute
		org.springframework.transaction.interceptor.RuleBasedTransactionAttribute


-----------------------------------------------
00. @EnableJpaRepositories
-----------------------------------------------

	- Refs: https://chatgpt.com/share/f10b8923-5551-45b4-bcc2-3c0aa8563f15?oai-dm=1

	- Annotation to enable JPA repositories.
	- Will scan the package of the annotated configuration class for Spring Data repositories by default.


-----------------------------------------------
00. @Query
-----------------------------------------------

	- Refs: https://chatgpt.com/share/f3f279ea-dbe1-4843-ac19-6c9d4ff3a760?oai-dm=1
				https://chatgpt.com/share/4e6a8799-b7da-4a45-b6e5-7762413b33ba?oai-dm=1

	- Spring Data JPA annotation :
		(1) For JPQL 			(Java Persistence Query Language)
		(2) For Native SQL 	(Database-specific SQL)

	- Annotation to declare finder queries directly on repository methods.

	- See Also:
			@Modifying


-----------------------------------------------
00. @Modifying
-----------------------------------------------

	- Refs: https://chatgpt.com/share/a3ddd671-72f4-4fcc-b084-2b01dd37e4a0?oai-dm=1

	- Spring Data JPA annotation

	- Indicates a query method should be considered as modifying query as that changes the way it needs to be executed.
	- This annotation is only considered if used on `query` methods defined through a `@Query` annotation.
	- It's not applied on custom implementation methods or queries derived from the method name
	   as they already have control overthe underlying data access APIs or specify if they are modifying by their name. 
	- Queries that require a `@Modifying` annotation include `INSERT`, `UPDATE`, `DELETE`, and `DDL` statements.

	- See Also: 
			@Query


-----------------------------------------------
00. @Param
-----------------------------------------------

	- Refs: https://chatgpt.com/share/b1312e3c-d3e2-4696-b014-88440fc91ac7?oai-dm=1

	- Spring Data JPA annotation

	- Annotation to bind method parameters to a query via a `named` parameter.


-----------------------------------------------
00. @SessionAttributes
-----------------------------------------------

	- Refs: https://chatgpt.com/share/4dc2fe0d-b3f8-4499-a1b0-1536b856a429

	- Annotation that indicates the session attributes that a specific handler uses. 
	- This will typically list the names of model attributes which should be transparently stored in the session or some conversational storage, serving as form-backing beans.
	- Declared at the type level, applyingto the model attributes that the annotated handler class operates on. 
	- NOTE: Session attributes as indicated using this annotationcorrespond to a specific handler's model attributes, getting transparently stored in a conversational session.
	- Those attributes will be removed oncethe handler indicates completion of its conversational session.
	- Therefore, use this facility for such conversational attributes which are supposed to be stored in the session temporarily during the course of a specific handler's conversation. 
	- For permanent session attributes, e.g. a user authentication object, use the traditional `session.setAttribute` method instead.
	- Alternatively, consider using the attribute management capabilities of the generic `org.springframework.web.context.request.WebRequest` interface. 
	- NOTE: When using controller interfaces (e.g. for AOP proxying), 
				  make sure to consistently put all your mapping annotations — such as `@RequestMapping` and `@SessionAttributes` — on the controller interface 
				  rather than on the implementation class.


-----------------------------------------------
00. @SessionAttribute
-----------------------------------------------

	- Refs: https://chatgpt.com/share/b74eb3bd-f685-4c5b-9bac-95d93af4ce81

	- 


-----------------------------------------------
00. @EnableSpringHttpSession
-----------------------------------------------

	- Refs: https://chatgpt.com/share/935a849c-14b0-4453-bb99-30c5fc032e5c

	- 


-----------------------------------------------
00. @EnableRedisHttpSession
-----------------------------------------------

	- Refs: https://chatgpt.com/share/01b0d3e2-7721-4bee-afde-e32eee3569da

	- 


-----------------------------------------------
00. @ModelAttribute
-----------------------------------------------

	- Refs: https://chatgpt.com/share/80a5e871-ac18-4c0b-b451-d5c4fd680ffd

	- Important: When this controller handler methods are invoked, called back automatically.	(***)

			@ModelAttribute("_MEMBER_")
			public Member createMember() {
				log.info("createMember() invoked.");
				return new Member();
			} // createMember

	- Annotation that binds a method parameter or method return value to a named model attribute, exposed to a web view.
	- Supported for controller classes with `@RequestMapping` methods. 
	- WARNING: Data binding can lead to security issues by exposing parts of the object graph that are not meant to be accessed or modified byexternal clients.
						 Therefore the design and use of data binding should be considered carefully with regard to security.
						  For more details, please refer to the dedicated sections on data binding for Spring Web MVC and Spring WebFluxin the reference manual. 
	- `@ModelAttribute` can be used to expose command objects to a web view, using specific attribute names,
		by annotating corresponding parameters of an `@RequestMapping` method. 
	- `@ModelAttribute` can also be used to expose reference data to a webview by annotating accessor methods in a controller class with `@RequestMapping` methods.
		Such accessor methods are allowed to have any arguments that `@RequestMapping` methods support, returning the model attribute value to expose. 
	- Note however that reference data and all other model content are not available to web views when request processing results in an Exception
	   since the exception could be raised at any timemaking the content of the model unreliable.
	   For this reason `@ExceptionHandler` methods do not provide access to a Model argument.


-----------------------------------------------
00. @RequestParam
-----------------------------------------------

	- Refs: https://chatgpt.com/share/e36a3382-bac9-4714-8927-9f3202cbfc07

	- 


-----------------------------------------------
00. @Qualifier
-----------------------------------------------

	- Refs: https://chatgpt.com/share/e51c2152-f257-4cc9-8253-5f693df67efe

	- 


-----------------------------------------------
00. @SessionScope
-----------------------------------------------

	- Refs: 	https://chatgpt.com/share/26c0fe40-c3fe-427f-aed9-1e97daf37f64

	- 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 


-----------------------------------------------
00. 
-----------------------------------------------

	- Refs: 
